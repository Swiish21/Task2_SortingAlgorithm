These two files are two sorting algorithms, one is a quicksort algorithm, the other is a merge sort algorithm.

File 1: QuickSort, we imprement this algorithm by first defining a function 'quickSort' whose parameter is the list we are going to sort, we begin by tacking our first case which is when a given list has a length of 1 or less, this automaticaly means that the list is sorted as you can't sort a list with one element, we use an if statement to tackle this case, if the case is true we return the list and don't proceed with the algorithm. In the case where our list is more than 1 in length, we need to continue with the algorithm, the quicksort alg works by selecting a pivot element, then spliting the array into two where the pivot elemnt is at the middle, then the quicksort is applied on both sides of the pivot and then the result is the combination of these 3 parts. We need to define a var to hold the value of the pivot element, then two more ('less' and 'greater') to store the elements of both sides of elements greater than and less than the pivot element. we'll continue with the alg by creating a for loop to go through the list, in the loop we define i as 1 since we don't want the loop to start at the pivot element (0), the condtion for the loop is that as long as i is less than the length of the list, it should continue to run. In the loop we use an if statement to check if the value of i in that specific iteration is greater than or less than the pivot, if greater than it will be added to the 'greater' list and likewise if less than the pivot. After the loop goes through all the elements in the list, it returns the combined parts of less than list, pivot element and greater than list in that specific order. We finish by passing a test case (unsorted list) to test our algorithm. We then print the final sorted list.

Problem Solved:
1. Write a dart function that implements a sorting algorithm(e.g quicksort, mergesort or bubblesort) to sort a list of integers.

File 2: Mergesort, the second algorithm is a mergesort algorithm that works by breaking down a list into two smaller equal parts(subarrays/sublists), sorts them then merges them into one sorted list, to start we define a function 'mergesort' that has a parameter 'list' which is the list to be sorted, like previously in the quickSort alg, we need to tackle the case where the list is less than or equal to one, meaning it's already sorted, we use an if statement(line 10 to 13) for this case, in the case where the list is more than 1 in length, we continue with the alg where we need to split the list into 2 equal parts, we define a midpoint 'middle' that stores the middle point of that list, then we define two sublists('left' and 'right') that store the left half of the list and right half respectively. We then continue by creating another function 'merge' whose work is to merge the two sublists, it's parameters are the 'left' and 'right' sublists, in this function we begin by defining 3 variables, 'result' that will hold the final sorted list,'i' and 'j' wto pointers that will be used to traverse the left and right sublists. To iterate we'll need a while loop with two conditions(as long i is less than the left sublist and as long as j is less than the right sublist), with each iteration of the while loop we get two different values of i and j , we continue by using an if statement to compare these value where if the left element is less than the right element we add it to the result list, if not we add the right to the result list, this will continue until all elements have been compared and sorted into the result list. But also what if we have a case where one sublist is actually longer than the other? if it's the left subslist we take all the remaining elements and add it to the result list, like wise with the right sublist, we finish by returning the sorted list('result') we pass a list to test the algorithm creating a variable 'sorted numbers' to hold the sorted list and print it for the user to see.  

Problem solved:
1. Implement two different sorting algorithms
2. Compare their speed in terms of execution time
 
*COMPARISON OF THESE TWO ALGORITHMS*

Based on the problem presented (sorting a simple list of integers), it is obvious that the quicksort algorithm is the better option for this, because of a few reasons:

Speed - it run through the list sorting and gives the sorted list result way faster compared to merge sort.

Steps and complexity - The mergesort algorithm has more a complex approach to a simple problem, spliting a simple list into sublists then merging them back is redundant, the quicksort just defines a pivot, compares the values of the list to it and sorts them to produce a sorted list, it takes fewer steps to achieve the same outcome.

